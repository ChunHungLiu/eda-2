// data.h -- May 9, 2009
//    by geohot
// part of "The Embedded Disassembler"
//  released under GPLv3, see http://gplv3.fsf.org/
//
// This contains all of EDA's data classes
// I can't include Logic or Presentation without screwing up

#include <map>

#include "data_atomic.h"

using namespace std;

// Memory
//   Address[]
//     Instruction
//     datamap_
//     name_

namespace eda {

// Instruction is no longer extended, InstructionFactory is
// Don't put the commit logic here, Instruction is a dumb storage class
class Instruction {
  Instruction(ParsedInstruction*, StatelessChangelist*, Address*, int length);
  // This should have a destructor that destroys parsed_ and stateless_
private:
  ParsedInstruction* parsed_;
  StatelessChangelist* change_;
  Address* start_;
  int length_;
};

// An address is one entry in the Memory Database
// It isn't tied to a 32-bit number in the space, that's the MMUs job
// Registers are also addresses
// It can be accessed by 32-bit address, name, or changelist

// Users are a very special case of Address,
// They can submit changelists directly
// Many methods don't have much signifance to them
class Address {
public:
  // Address accessor functions
  // All return pointer to address after last one got
  // NULL if said address doesn't exist
  Address* get8(uint8* data);
  Address* get16(uint16* data);
  Address* get32(uint32* data);
  // Address mutator functions are only to be called from commit

  // Operators to walk you through the address list
  Address* operator++ (Address*);
  Address* operator-- (Address*);

  // Names can't start with numbers, enforce this
  bool set_name(const string& name);

private:
  // Maps changelistNumbers to 8-bit datas
  map<int, uint8> datamap_;

  // Name of this address
  string name_;

  // If not null, the instruction at this address
  Instruction* instruction_;

  // These allow for traversing the address space
  // And let functions like get32 work
  Address* prev_;
  Address* next_;
};

class History {
  // The destruction of a Memory object is too much for EDA
public:
  // Changelists never get deleted, so this gets a pointer
  // This also gets the current address when the instruction was commited
  void AddCommited(Changelist*);
private:
  // Save every changelist ever commited into the memory database
  map<int, Changelist*> changelists_;

  // Given an Address, I'd like to know what it has done
  // Map addresses to changelists that they commited
  map<Address*, vector<int> > modifiers_;

  // This can be generated by walking the
  // Map addresses to changelists that affected them
  map<Address*, vector<int> > modified_;
};


}
